#! /usr/bin/perl

use strict; 
use warnings; 
use File::Copy; 
use File::Basename; 

if (@ARGV != 1)
{
    my $usage = qq {
usage: recipeParser.pl recipe.txt

Creates a simple HTML page from the original recipe using this format: 
    Recipe Name 
    Source
    Serves ##
    ## Minutes/Hours
    Ingredients
    Ingredient 1
    Ingredient 2 
    ...
    Directions
    Step 1
    Step 2
    ... 
};
    print $usage; 
    exit 1; 
}

my $inputFile = $ARGV[0];
my $outputFile = "";
my $path = ""; 
my $name = "";
my $source = "";
my $serves = "";
my $time = "";
my @ingredients; 
my @directions; 
my $suffix; 
# State used to indicate where in the file we are
# 0 - Next line should be recipe title
# 1 - Next line should be source
# 2 - Next line should be the number of people served
# 3 - Next line should be the time required
# 4 - Next lines should be ingredients list (need to check for directions)
# 5 - Next lines contain cooking directions
my $state = 0; 
# Read in the recipe

# Get the path to create the final output file 
$path = dirname $inputFile;

open my $input, '<', $inputFile or die "Unable to open $inputFile: $!.";
while (my $line = <$input>)
{
    chomp $line;
    if ($state == 0) 
    {
        $name = $line; 
        # Make the output file name a hyphenated version of the recipe name
        $outputFile = lc $name;
        $outputFile =~ s/ /-/g;
        # Strip out any non alphanumeric characters or hyphens
        $outputFile =~ s/[^a-z0-9\-]//g;
        $outputFile = $path . '/' . $outputFile . ".html"; 
        $state ++; 
    }
    elsif ($state == 1)
    {
        $source = $line; 
        $state ++; 
    }
    elsif ($state == 2)
    {
        $serves = $line;
        $state ++; 
    }
    elsif ($state == 3) 
    {
        $time = $line; 
        $state ++; 
    }
    elsif ($state == 4)
    {
        # Catch the ingredients/directions headers
        if ($line =~ /^(Directions|Ingredients)/) {
            
            # If it's directions, move to the next state
            if ($1 =~ /Directions/)
            {
                $state ++; 
            }
            # Otherwise do nothing
        }
        # If it is not the ingredients header, save it
        else
        {
            push(@ingredients, $line); 
        }
    }
    elsif ($state == 5) 
    { 
        push(@directions, $line); 
    }
}    # End reading the input file

# Generate the output file
open my $output, '>', $outputFile or die "Unable to open output file $outputFile: $!";

my $html = qq {<html>

<!-- Autogenerated with recipeParser.pl -->

<head>
    <title>Recipe for $name</title>
    <meta charset = "utf-8">
    <meta name = "viewport" content = "width=device-width, initial-scale = 1.0">
    <link rel = "stylesheet" type = "text/css" href = "/main.css">
</head>

<body>
    <div class = "recipes">
        <h1> $name </h1>
        <h4> $source | $serves | Takes $time </h4>

        <div class = "ingredients">
            <h2> Ingredients </h2>
            <ul> 
}; 
print $output "$html";

foreach my $line (@ingredients)
{
    print $output "\t\t\t\t<li> $line </li>\n";
}

$html = qq {\t\t\t</ul>
        </div>

        <div class = "directions">
            <h2> Directions </h2>

            <ol>
} ;
print $output "$html";

foreach my $line (@directions)
{
    print $output "\t\t\t\t<li> $line </li>\n";
}

$html = qq{\t\t\t</ol>
        </div>
    </div>
</body>

</html>
}; 

print $output "$html";
